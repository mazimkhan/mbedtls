#line 2 "embedded_test.function"

#include "greentea-client/test_env_c.h"

#define INCR_ASSERT(p, start, len, step) do                     \
{                                                               \
    assert( p >= start );                                       \
    assert( sizeof( *p ) == sizeof( *start ) );                 \
    assert( (uint32_t)( (p - start) + step ) <= len );          \
    p += step;                                                  \
}                                                               \
while( 0 )

#define ALIGN_32BIT(p, start, len) do           \
{                                               \
    uint32_t align = ( - (uintptr_t)p ) % 4;    \
    INCR_ASSERT(p, start, len, align);          \
}                                               \
while( 0 )


/**
 * \brief       Frees the parameters memory allocated by receive_parameters()
 *
 * \param params    Array of parameters
 *
 * \return          void
 */
int verify_dependencies( uint8_t count, uint8_t * dep_p )
{
    uint8_t i;
    for ( i = 0; i < count; i++ )
    {
        if ( dep_check( (int)(dep_p[i]) ) != DEPENDENCY_SUPPORTED )
            return( DEPENDENCY_NOT_SUPPORTED );
    }
    return( DEPENDENCY_SUPPORTED );
}


uint32_t receive_uint32()
{
    uint32_t value;
    value =  (uint8_t)greentea_getc() << 24;
    value |= (uint8_t)greentea_getc() << 16;
    value |= (uint8_t)greentea_getc() << 8;
    value |= (uint8_t)greentea_getc();
    return( (uint32_t)value );
}

uint32_t parse_uint32( uint8_t * p )
{
    uint32_t value;
    value =  *p++ << 24;
    value |= *p++ << 16;
    value |= *p++ << 8;
    value |= *p;
    return( value );
}


void receive_bytes(uint8_t * buf, uint32_t len)
{
    uint32_t i;

    for( i = 0; i < len; i++ )
    {
        buf[i] = greentea_getc();
    }
}

/**
 * \brief       Receives test data on serial and processes it for execution.
 *
 * \param none
 *
 * \return      Array of parameters. NULL on failure.
 */
uint8_t * receive_data( uint32_t * data_len )
{
    uint32_t i = 0, errors = 0;
    char c;
    uint8_t * data = NULL;

    /* Read opening braces */
    i = 0;
    while ( i < 2 )
    {
        c = greentea_getc();
        /* Ignore any prevous CR LF characters */
        if ( c == '\n' || c == '\r' )
            continue;
        i++;
        if ( c != '{' )
            return( NULL );
    }

    /* Read number of params */
    *data_len = receive_uint32();
    data = (uint8_t *)malloc( *data_len );

    greentea_getc(); // read ';' received after key i.e. *data_len

    for( i = 0; i < *data_len; i++ )
        data[i] = greentea_getc();

    /* Read closing braces */
    for( i = 0; i < 2; i++ )
    {
        c = greentea_getc();
        if ( c != '}' )
        {
            errors++;
            break;
        }
    }

    if ( errors )
    {
        free( data );
        data = NULL;
        *data_len = 0;
    }

    return( data );
}

/**
 * \brief       Receives test data on serial and processes it for execution.
 *
 * \param none
 *
 * \return      Array of parameters. NULL on failure.
 */
void ** parse_parameters( uint8_t count, uint8_t * data, uint32_t data_len, int * error )
{
    uint32_t i = 0;
    char c;
    void ** params = NULL;
    void ** cur = NULL;
    uint8_t * p = NULL;

    params = (void **)malloc( ( sizeof( void *) * count ) + 1 );
    params[count] = NULL;
    cur = params;

    p = data;

    /* Parameters */
    for( i = 0; i < count; i++ )
    {
        c = (char)*p;
        INCR_ASSERT( p, data, data_len, 1 );

        /* Align p to 4 bytes for int, expression, string len or hex length */
        ALIGN_32BIT( p, data, data_len );

        /* Network to host conversion */
        *( (int32_t *)p ) = (int32_t)parse_uint32( p );
        //printf ("typ %c val %d\r\n", c, *( (int32_t *)p ) );

        switch( c )
        {
            case 'E':
                {
                    if ( get_expression( *( (int32_t *)p ), (int32_t *)p ) )
                    {
                        *error = KEY_VALUE_MAPPING_NOT_FOUND;
                        goto exit;
                    }
                } /* Intentional fall through */
            case 'I':
                {
                    *cur++ = (void *)p;
                    INCR_ASSERT( p, data, data_len, sizeof( int32_t ) );
                }
                break;
            case 'H':
                {
                    *cur++ = (void *)p;
                } /* Intentional fall through */
            case 'S':
                {
                    uint32_t sz = *( (int32_t *)p );
                    INCR_ASSERT( p, data, data_len, sizeof( int32_t ) );
                    *cur++ = (void *)p;
                    INCR_ASSERT( p, data, data_len, sz );
                }
                break;
            default:
                    {
                        *error = DISPATCH_INVALID_TEST_DATA;
                        goto exit;
                    }
                break;
        }
    }

exit:
    if ( *error )
    {
        free( params );
        params = NULL;
    }

    return( params );
}

/**
 * \brief       Receives test data on serial and processes it for execution.
 *
 * \param none
 *
 * \return      Array of parameters. NULL on failure.
 */
void send_key_integer( char * key, int failure )
{
    char str[50];
    snprintf( str, sizeof( str ), "%d", failure );
    greentea_send_kv_c( key, str );
}

void send_failure( int failure )
{
    send_key_integer( "F", failure );
}

void send_status( int status )
{
    send_key_integer( "R", status );
}


/**
 * \brief       Embedded implementation of execute_tests().
 *              Ignores command line and received test data
 *              on serial.
 *
 * \param argc  not used
 * \param argv  not used
 *
 * \return      Program exit status.
 */
int execute_tests( int args, const char ** argv )
{
    int ret = 0;
    uint32_t data_len = 0;
    uint8_t count = 0, function_id;
    void ** params = NULL;
    uint8_t * data = NULL, * p = NULL;

    GREENTEA_SETUP_C( 180, "mbedtls_test" );
    greentea_send_kv_c( "GO", " " );

    while ( 1 )
    {
        ret = 0;
        test_errors = 0;
        data_len = 0;
        data = receive_data( &data_len );
        if ( data == NULL )
            continue;
        p = data;

        do
        {
            count = *p;
            INCR_ASSERT( p, data, data_len, 1 );
            ret = verify_dependencies( count, p );
            if ( ret != DEPENDENCY_SUPPORTED )
                break;

            p += count;

            function_id = *p;
            INCR_ASSERT( p, data, data_len, 1 );

            /* Number of parameters */
            count = *p;
            INCR_ASSERT( p, data, data_len, 1 );

            params = parse_parameters( count, p, data_len - (p - data), &ret );
            if ( ret )
                break;

            printf("before dispatch_test\r\n");
            ret = dispatch_test( function_id, params );
            printf("after dispatch_test\r\n");
        }
        while ( 0 );

        if ( data )
        {
            free(data);
            data = NULL;
        }

        if ( params )
        {
            free( params );
            params = NULL;
        }

        if ( ret )
            send_failure( ret );
        else
            send_status( test_errors );
    }
    return( 0 );
}



